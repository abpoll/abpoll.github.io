---
title: "Publications"
execute:
  kernel: quarto-web
  echo: false
  warning: false
  message: false
---

```{python}
#| output: asis
from pathlib import Path
import html
import re
import bibtexparser

BIB_PATH = Path("../bibliography/my-papers.bib")

# ---------- helpers ----------
def clean_braces(s: str) -> str:
    if s is None:
        return ""
    s = re.sub(r"[{}]", "", str(s))
    s = re.sub(r"\s+", " ", s)  # collapse line breaks / extra spaces
    return s.strip()

def norm_bool_str(x) -> bool:
    if x is None:
        return False
    return str(x).strip().strip("{}").strip().lower() in ("true", "yes", "1", "y")

def get_year(e) -> int:
    y = e.get("year")
    if y:
        try:
            return int(str(y)[:4])
        except:
            pass
    d = e.get("date")  # biblatex style: YYYY-MM-DD
    if d:
        m = re.match(r"(\d{4})", str(d).strip())
        if m:
            return int(m.group(1))
    return 0

def entrytype(e) -> str:
    return (e.get("ENTRYTYPE") or "").strip().lower()

def get_primary_link(e):
    doi = (e.get("doi") or "").strip()
    url = (e.get("url") or "").strip()
    if doi:
        return doi if doi.startswith("http") else f"https://doi.org/{doi}"
    if url:
        return url
    return None

def shields_img(url, alt):
    return f'<img src="{html.escape(url)}" alt="{html.escape(alt)}">'

def badge_link(href, img_url, alt):
    return (
        f'<a class="pub-badge-link" href="{html.escape(href)}" target="_blank" rel="noopener">'
        f'{shields_img(img_url, alt)}'
        f'</a>'
    )

def repo_badge(repo_url):
    r = (repo_url or "").strip().lower()
    if "github" in r:
        return badge_link(
            repo_url,
            "https://img.shields.io/static/v1?style=flat&logo=github&label=&message=Open%20Source",
            "GitHub Repository",
        )
    if "bitbucket" in r:
        return badge_link(
            repo_url,
            "https://img.shields.io/static/v1?style=flat&logo=bitbucket&label=&message=Open%20Source",
            "Bitbucket Repository",
        )
    if "gitlab" in r:
        return badge_link(
            repo_url,
            "https://img.shields.io/static/v1?style=flat&logo=gitlab&label=&message=Open%20Source",
            "GitLab Repository",
        )
    return badge_link(
        repo_url,
        "https://img.shields.io/badge/Repository-gray?style=flat",
        "Repository",
    )

def preprint_badge(preprint_url):
    p = (preprint_url or "").strip().lower()
    if "arxiv" in p:
        return badge_link(
            preprint_url,
            "https://img.shields.io/static/v1?label=&message=Preprint&color=purple&logo=arxiv&style=flat",
            "Preprint (arXiv)",
        )
    return badge_link(
        preprint_url,
        "https://img.shields.io/static/v1?label=&message=Preprint&color=purple&style=flat",
        "Preprint",
    )

# ---------- author logic (NEW) ----------
def split_authors(author_field: str):
    # BibTeX authors are separated by " and "
    if not author_field:
        return []
    author_field = clean_braces(author_field)
    parts = [a.strip() for a in author_field.split(" and ") if a.strip()]
    return parts

def is_me(author: str) -> bool:
    a = author.lower().replace(".", "").strip()
    # covers: "Pollack, Adam", "Pollack, Adam B", "Pollack, A", "Adam Pollack"
    if "pollack" not in a:
        return False
    if "adam" in a:
        return True
    # e.g., "Pollack, A"
    if re.search(r"\bpollack,\s*a\b", a) is not None:
        return True
    return False

def format_authors(author_field: str, max_names: int = 4) -> str:
    """
    Display up to max_names authors without reordering.
    Always bold 'me' if present.

    If there are > max_names authors:
      - if 'me' is in the first max_names: show first max_names (+ et al.)
      - else: show first (max_names - 2), then [因, then me, then et al.

    This preserves true author order and avoids moving 'me' earlier.
    """
    authors = split_authors(author_field)
    if not authors:
        return ""

    # Find position of me
    me_idx = None
    for i, a in enumerate(authors):
        if is_me(a):
            me_idx = i
            break

    n = len(authors)
    truncated = n > max_names

    def fmt_name(a: str) -> str:
        if is_me(a):
            return f"<strong>{html.escape(a)}</strong>"
        return html.escape(a)

    # If not truncated, just list all (with me bolded)
    if not truncated:
        return ", ".join(fmt_name(a) for a in authors)

    # Truncated case
    # If me is among the first max_names (or not present at all), show first max_names
    if me_idx is None or me_idx < max_names:
        shown = [fmt_name(a) for a in authors[:max_names]]
        shown.append("et al.")
        return ", ".join(shown)

    # Me is NOT in the first max_names authors:
    # show first (max_names - 2), then [因, then me, then et al.
    # e.g. max_names=4 => first 2, [因, me, et al.
    head_count = max(1, max_names - 2)
    head = [fmt_name(a) for a in authors[:head_count]]
    me = fmt_name(authors[me_idx])

    shown = head + ["<span class='pub-ellipsis'>[因</span>", me, "et al."]
    return ", ".join(shown)

def alpha_note(e) -> str:
    if norm_bool_str(e.get("alpha")):
        return "<div class='pub-alpha'>(non-lead authors listed alphabetically)</div>"
    return ""

# ---------- reference rendering ----------
def format_reference(e) -> str:
    authors_html = format_authors(e.get("author", ""), max_names=4)
    year = get_year(e)
    title = clean_braces(e.get("title", ""))
    venue = clean_braces(e.get("journal") or e.get("journaltitle") or e.get("booktitle") or "")
    vol = clean_braces(e.get("volume", ""))
    num = clean_braces(e.get("number", ""))
    pages = clean_braces(e.get("pages", ""))

    pieces = []
    if authors_html:
        pieces.append(f"{authors_html}.")
    if year:
        pieces.append(f"({year}).")
    if title:
        pieces.append(f"<span class='pub-title'>{html.escape(title)}</span>.")
    if venue:
        pieces.append(f"<span class='pub-venue'>{html.escape(venue)}</span>")
    if vol:
        vn = f"<span class='pub-vol'>{html.escape(vol)}</span>"
        if num:
            vn += f"(<span class='pub-num'>{html.escape(num)}</span>)"
        pieces.append(vn)
    if pages:
        pieces.append(f"<span class='pub-pages'>{html.escape(pages)}</span>")

    ref = " ".join([p for p in pieces if p])
    ref += alpha_note(e)
    return ref

# ---------- card rendering ----------
def render_entry(e):
    link = get_primary_link(e)
    open_access = norm_bool_str(e.get("open"))
    repo = e.get("repo")
    preprint = e.get("preprint")

    badges = []
    if link:
        if open_access:
            badges.append(
                badge_link(
                    link,
                    "https://img.shields.io/static/v1?label=&message=Open%20Access&color=green&style=flat",
                    "Open Access",
                )
            )
        else:
            badges.append(
                badge_link(
                    link,
                    "https://img.shields.io/static/v1?label=&message=Published&color=blue&style=flat",
                    "Published",
                )
            )
    if repo:
        badges.append(repo_badge(repo))
    if preprint:
        badges.append(preprint_badge(preprint))

    ref_html = format_reference(e)
    key = html.escape(e.get("ID", ""))

    notes_html = ""
    if badges:
        notes_html = "<div class='bibcard-notes'>" + "".join(badges) + "</div>"

    card_html = (
        "<div class='pub-card'>"
        f"<div class='bibcard-ref' id='{key}'>{ref_html}</div>"
        f"{notes_html}"
        "</div>"
    )
    print(card_html)

# ---------- load + partition ----------
if not BIB_PATH.exists():
    print(f"**Error:** Could not find `{BIB_PATH}`. Make sure the bibliography submodule is initialized.")
else:
    with BIB_PATH.open(encoding="utf-8") as fh:
        bib = bibtexparser.load(fh)

    entries = bib.entries

    sections = [
        ("Journal Articles", {"article"}),
        ("Papers In Review or In Press", {"unpublished"}),
        ("Reports", {"techreport"}),
    ]

    used_ids = set()
    for section_title, types in sections:
        print(f"\n\n## {section_title}\n")

        section_entries = [e for e in entries if entrytype(e) in types]
        section_entries.sort(
            key=lambda e: (get_year(e), clean_braces(e.get("title", "")).lower()),
            reverse=True,
        )

        if not section_entries:
            print("<p class='text-muted'>No entries found in this section.</p>")
            continue

        for e in section_entries:
            used_ids.add(e.get("ID"))
            render_entry(e)
```