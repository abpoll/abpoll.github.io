---
title: "Publications"
execute:
  kernel: quarto-web
  echo: false
  warning: false
  message: false
---


```{python}
#| output: asis
from pathlib import Path
import html
import re
from collections import defaultdict

import bibtexparser

BIB_PATH = Path("../bibliography/my-papers.bib")

# ---------- helpers ----------
def clean_braces(s: str) -> str:
    if s is None:
        return ""
    return re.sub(r"[{}]", "", str(s)).strip()

def norm_bool_str(x) -> bool:
    if x is None:
        return False
    return str(x).strip().strip("{}").strip().lower() in ("true", "yes", "1", "y")

def get_year(e) -> int:
    # BibTeX style
    y = e.get("year")
    if y:
        try:
            return int(str(y)[:4])
        except:
            pass
    # BibLaTeX style
    d = e.get("date")  # e.g. 2026-01-20
    if d:
        m = re.match(r"(\d{4})", str(d).strip())
        if m:
            return int(m.group(1))
    return 0

def entrytype(e) -> str:
    return (e.get("ENTRYTYPE") or "").strip().lower()

def get_primary_link(e):
    doi = (e.get("doi") or "").strip()
    url = (e.get("url") or "").strip()
    if doi:
        return doi if doi.startswith("http") else f"https://doi.org/{doi}"
    if url:
        return url
    return None

def shields_img(url, alt):
    return f'<img src="{html.escape(url)}" alt="{html.escape(alt)}">'

def badge_link(href, img_url, alt):
    return (
        f'<a class="pub-badge-link" href="{html.escape(href)}" target="_blank" rel="noopener">'
        f'{shields_img(img_url, alt)}'
        f'</a>'
    )

def repo_badge(repo_url):
    r = (repo_url or "").strip().lower()
    if "github" in r:
        return badge_link(
            repo_url,
            "https://img.shields.io/static/v1?style=flat&logo=github&label=&message=Open%20Source",
            "GitHub Repository",
        )
    if "bitbucket" in r:
        return badge_link(
            repo_url,
            "https://img.shields.io/static/v1?style=flat&logo=bitbucket&label=&message=Open%20Source",
            "Bitbucket Repository",
        )
    if "gitlab" in r:
        return badge_link(
            repo_url,
            "https://img.shields.io/static/v1?style=flat&logo=gitlab&label=&message=Open%20Source",
            "GitLab Repository",
        )
    return badge_link(
        repo_url,
        "https://img.shields.io/badge/Repository-gray?style=flat",
        "Repository",
    )

def preprint_badge(preprint_url):
    p = (preprint_url or "").strip().lower()
    if "arxiv" in p:
        return badge_link(
            preprint_url,
            "https://img.shields.io/static/v1?label=&message=Preprint&color=purple&logo=arxiv&style=flat",
            "Preprint (arXiv)",
        )
    return badge_link(
        preprint_url,
        "https://img.shields.io/static/v1?label=&message=Preprint&color=purple&style=flat",
        "Preprint",
    )

def format_reference(e) -> str:
    authors = clean_braces(e.get("author", "")).replace("\n", " ").strip()
    year = get_year(e)
    title = clean_braces(e.get("title", ""))
    venue = clean_braces(e.get("journal") or e.get("journaltitle") or e.get("booktitle") or "")
    vol = clean_braces(e.get("volume", ""))
    num = clean_braces(e.get("number", ""))
    pages = clean_braces(e.get("pages", ""))
    pieces = []

    if authors:
        pieces.append(f"{html.escape(authors)}.")
    if year:
        pieces.append(f"({year}).")
    if title:
        pieces.append(f"<span class='pub-title'>{html.escape(title)}</span>.")
    if venue:
        pieces.append(f"<span class='pub-venue'>{html.escape(venue)}</span>")
    if vol:
        vn = f"<span class='pub-vol'>{html.escape(vol)}</span>"
        if num:
            vn += f"(<span class='pub-num'>{html.escape(num)}</span>)"
        pieces.append(vn)
    if pages:
        pieces.append(f"<span class='pub-pages'>{html.escape(pages)}</span>")

    # Join with spaces, then add a DOI/url line if present
    ref = " ".join([p for p in pieces if p])
    return ref

def split_authors(author_field: str):
    # BibTeX authors are separated by " and "
    if not author_field:
        return []
    parts = [a.strip() for a in author_field.replace("\n", " ").split(" and ") if a.strip()]
    return parts

def is_me(author: str) -> bool:
    # Robust match for your name in common BibTeX forms
    a = author.lower().replace(".", "").strip()
    # handles "Pollack, Adam", "Pollack, Adam B", "Pollack, A", "Adam Pollack"
    return ("pollack" in a) and (("adam" in a) or re.search(r"\bpollack,\s*a\b", a) is not None)

def bold_me(author: str) -> str:
    return f"<strong>{html.escape(author)}</strong>"

def format_authors(author_field: str, max_names: int = 4) -> str:
    authors = split_authors(clean_braces(author_field))
    if not authors:
        return ""

    # Find "me" if present
    me_idx = None
    for i, a in enumerate(authors):
        if is_me(a):
            me_idx = i
            break

    # Build a displayed list of up to max_names, but always include me if found
    displayed = authors[:max_names]
    truncated = len(authors) > max_names

    if me_idx is not None:
        me_author = authors[me_idx]
        # ensure me is in displayed
        if me_author not in displayed:
            # make room: drop last displayed author and insert me at position 1
            if displayed:
                displayed = displayed[:-1]
            insert_pos = 1 if len(displayed) >= 1 else 0
            displayed.insert(insert_pos, me_author)

    # Bold me in displayed list
    disp_html = []
    for a in displayed:
        if is_me(a):
            disp_html.append(bold_me(a))
        else:
            disp_html.append(html.escape(a))

    # Add et al. if truncated
    if truncated:
        disp_html.append("et al.")

    return ", ".join(disp_html)

def alpha_note(e) -> str:
    # supports alpha={true} or author_order={alphabetical}
    if norm_bool_str(e.get("alpha")):
        return " <span class='pub-alpha'>(authors listed alphabetically)</span>"
    ao = (e.get("author_order") or "").strip().lower()
    if ao in ("alphabetical", "alpha", "alphabetic"):
        return " <span class='pub-alpha'>(authors listed alphabetically)</span>"
    return ""

def render_entry(e):
    link = get_primary_link(e)
    open_access = norm_bool_str(e.get("open"))
    repo = e.get("repo")
    preprint = e.get("preprint")

    badges = []
    if link:
        if open_access:
            badges.append(
                badge_link(
                    link,
                    "https://img.shields.io/static/v1?label=&message=Open%20Access&color=green&style=flat",
                    "Open Access",
                )
            )
        else:
            badges.append(
                badge_link(
                    link,
                    "https://img.shields.io/static/v1?label=&message=Published&color=blue&style=flat",
                    "Published",
                )
            )

    if repo:
        badges.append(repo_badge(repo))

    if preprint:
        badges.append(preprint_badge(preprint))

    ref_html = format_reference(e)
    key = html.escape(e.get("ID", ""))

    notes_html = ""
    if badges:
        notes_html = f"<div class='bibcard-notes'>{''.join(badges)}</div>"

    card_html = (
        "<div class='pub-card'>"
        f"<div class='bibcard-ref' id='{key}'>{ref_html}</div>"
        f"{notes_html}"
        "</div>"
    )

    print(card_html)

# Load data and print by group
if not BIB_PATH.exists():
    print(f"**Error:** Could not find `{BIB_PATH}`. Make sure the bibliography submodule is initialized.")
else:
    with BIB_PATH.open(encoding="utf-8") as fh:
        bib = bibtexparser.load(fh)

    entries = bib.entries

    sections = [
        ("Journal Articles", {"article"}),
        ("Papers In Review or In Press", {"unpublished"}),
        ("Reports", {"techreport"}),
    ]

    # Print sections
    used_ids = set()
    for title, types in sections:
        print(f"\n\n## {title}\n")

        section_entries = [e for e in entries if entrytype(e) in types]
        # sort by year desc, then title
        section_entries.sort(key=lambda e: (get_year(e), clean_braces(e.get("title","")).lower()), reverse=True)

        if not section_entries:
            print("<p class='text-muted'>No entries found in this section.</p>")
            continue

        for e in section_entries:
            used_ids.add(e.get("ID"))
            render_entry(e)
```